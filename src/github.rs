use crate::analyzer::{AnalysisReport, Finding, Severity};
use serde_json::json;

/// Format findings into a markdown report for PR comments.
pub fn format_report(report: &AnalysisReport) -> String {
    if report.findings.is_empty() {
        return format!(
            "## Anchor Security Report\n\n\
             No issues found across {} files scanned.\n\n\
             All checks passed.",
            report.files_scanned
        );
    }

    let high: Vec<&Finding> = report
        .findings
        .iter()
        .filter(|f| f.severity == Severity::High)
        .collect();
    let medium: Vec<&Finding> = report
        .findings
        .iter()
        .filter(|f| f.severity == Severity::Medium)
        .collect();
    let low: Vec<&Finding> = report
        .findings
        .iter()
        .filter(|f| f.severity == Severity::Low)
        .collect();

    let mut md = format!(
        "## Anchor Security Report\n\n\
         **{} issue(s)** found across {} files scanned.\n\n",
        report.findings.len(),
        report.files_scanned
    );

    if !high.is_empty() {
        md.push_str("### High Severity\n\n");
        for f in &high {
            md.push_str(&format_finding(f));
        }
        md.push('\n');
    }

    if !medium.is_empty() {
        md.push_str("### Medium Severity\n\n");
        for f in &medium {
            md.push_str(&format_finding(f));
        }
        md.push('\n');
    }

    if !low.is_empty() {
        md.push_str("### Low Severity\n\n");
        for f in &low {
            md.push_str(&format_finding(f));
        }
        md.push('\n');
    }

    md.push_str("---\n*Generated by [anchor-audit-action](https://github.com/avhidotsol/anchor-audit-action)*");

    md
}

fn format_finding(f: &Finding) -> String {
    format!(
        "- **`{}`** in `{}:{}`\n  {}\n",
        f.check, f.file, f.line, f.message
    )
}

/// Post a comment on a pull request via the GitHub API.
pub async fn post_pr_comment(
    token: &str,
    repo: &str,
    pr_number: u64,
    body: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let url = format!(
        "https://api.github.com/repos/{}/issues/{}/comments",
        repo, pr_number
    );

    let client = reqwest::Client::new();
    let resp = client
        .post(&url)
        .header("Authorization", format!("Bearer {}", token))
        .header("Accept", "application/vnd.github+json")
        .header("User-Agent", "anchor-audit-action")
        .header("X-GitHub-Api-Version", "2022-11-28")
        .json(&json!({ "body": body }))
        .send()
        .await?;

    if !resp.status().is_success() {
        let status = resp.status();
        let text = resp.text().await.unwrap_or_default();
        return Err(format!("GitHub API error {}: {}", status, text).into());
    }

    Ok(())
}

/// Create a check run on the commit via the GitHub Checks API.
pub async fn create_check_run(
    token: &str,
    repo: &str,
    head_sha: &str,
    report: &AnalysisReport,
) -> Result<(), Box<dyn std::error::Error>> {
    let url = format!("https://api.github.com/repos/{}/check-runs", repo);

    let conclusion = if report.has_high() {
        "failure"
    } else if report.has_medium_or_above() {
        "neutral"
    } else if report.findings.is_empty() {
        "success"
    } else {
        "neutral"
    };

    let summary = if report.findings.is_empty() {
        format!(
            "No issues found across {} files.",
            report.files_scanned
        )
    } else {
        format!(
            "{} issue(s) found across {} files.",
            report.findings.len(),
            report.files_scanned
        )
    };

    let annotations: Vec<serde_json::Value> = report
        .findings
        .iter()
        .take(50) // GitHub limits annotations to 50 per request
        .map(|f| {
            json!({
                "path": f.file,
                "start_line": f.line,
                "end_line": f.line,
                "annotation_level": match f.severity {
                    Severity::High => "failure",
                    Severity::Medium => "warning",
                    Severity::Low => "notice",
                },
                "title": f.check,
                "message": f.message,
            })
        })
        .collect();

    let body = json!({
        "name": "Anchor Security Audit",
        "head_sha": head_sha,
        "status": "completed",
        "conclusion": conclusion,
        "output": {
            "title": "Anchor Security Audit",
            "summary": summary,
            "annotations": annotations,
        }
    });

    let client = reqwest::Client::new();
    let resp = client
        .post(&url)
        .header("Authorization", format!("Bearer {}", token))
        .header("Accept", "application/vnd.github+json")
        .header("User-Agent", "anchor-audit-action")
        .header("X-GitHub-Api-Version", "2022-11-28")
        .json(&body)
        .send()
        .await?;

    if !resp.status().is_success() {
        let status = resp.status();
        let text = resp.text().await.unwrap_or_default();
        // Check runs require specific permissions â€” log but don't fail
        eprintln!(
            "Warning: Could not create check run ({}): {}",
            status, text
        );
    }

    Ok(())
}

/// Extract the PR number from the GitHub event payload file.
pub fn get_pr_number_from_event(event_path: &str) -> Option<u64> {
    let data = std::fs::read_to_string(event_path).ok()?;
    let event: serde_json::Value = serde_json::from_str(&data).ok()?;
    event["pull_request"]["number"].as_u64().or_else(|| {
        event["number"].as_u64()
    })
}

/// Extract the head SHA from the GitHub event payload.
pub fn get_head_sha_from_event(event_path: &str) -> Option<String> {
    let data = std::fs::read_to_string(event_path).ok()?;
    let event: serde_json::Value = serde_json::from_str(&data).ok()?;
    event["pull_request"]["head"]["sha"]
        .as_str()
        .map(|s| s.to_string())
}
